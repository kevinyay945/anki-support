Index: infrastructure/anki/anki.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package anki\n\nimport (\n\t\"fmt\"\n\t\"github.com/atselvan/ankiconnect\"\n\t\"github.com/imroc/req/v3\"\n\t\"github.com/privatesquare/bkst-go-utils/utils/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype Client struct {\n\tankiConnect   *ankiconnect.Client\n\tankiMediaPath string\n\thttpClient    *req.Client\n\tlog           *logrus.Entry\n}\n\nfunc NewClient(log *logrus.Logger) *Client {\n\tfield := log.WithField(\"infrastructure\", \"anki\")\n\tc := &Client{log: field}\n\tc.ankiConnect = ankiconnect.NewClient()\n\tc.httpClient = req.C()\n\tc.httpClient.SetBaseURL(\"http://127.0.0.1:8765\")\n\tif path, err := c.GetMediaFolderPath(); err != nil {\n\t\tc.log.Warnf(\"Fail To Get Media Folder: %s\", err.Error())\n\t} else {\n\t\tc.ankiMediaPath = path\n\t}\n\treturn c\n}\n\nfunc (c *Client) Ping() (err error) {\n\trestErr := c.ankiConnect.Ping()\n\treturn NewAnkiError(restErr)\n}\n\nfunc (c *Client) GetAllDeck() ([]string, error) {\n\tall, err := c.ankiConnect.Decks.GetAll()\n\treturn *all, NewAnkiError(err)\n}\n\nfunc (c *Client) GetAllNoteFromDeck(name string) ([]ankiconnect.ResultNotesInfo, error) {\n\tget, err := c.ankiConnect.Notes.Get(fmt.Sprintf(\"deck:%s\", name))\n\treturn *get, NewAnkiError(err)\n}\n\nfunc (c *Client) GetTodoNoteFromDeck(deckName string) ([]ankiconnect.ResultNotesInfo, error) {\n\ttodoTag := \"anki-helper-vocabulary-todo\"\n\tget, err := c.ankiConnect.Notes.Get(fmt.Sprintf(\"tag:%s deck:%s\", todoTag, deckName))\n\treturn *get, NewAnkiError(err)\n}\n\n// EditNoteById should be careful that you can't edit tag, and you can't edit when you open this card on anki gui\nfunc (c *Client) EditNoteById(\n\tnote ankiconnect.ResultNotesInfo,\n\taudioList []ankiconnect.Audio,\n\tvideoList []ankiconnect.Video,\n\tpictureList []ankiconnect.Picture,\n) error {\n\tupdateFields := map[string]string{}\n\tfor s, data := range note.Fields {\n\t\tupdateFields[s] = data.Value\n\t}\n\tvar oldAudioList []ankiconnect.Audio\n\tfor _, audio := range audioList {\n\t\tif audio.Path == \"\" {\n\t\t\toldAudioList = append(oldAudioList, audio)\n\t\t\tcontinue\n\t\t}\n\t\tinput, err := os.ReadFile(audio.Path)\n\t\tif err != nil {\n\t\t\tc.log.Warnf(\"Fail to read audio file: %s\", err.Error())\n\t\t\toldAudioList = append(oldAudioList, audio)\n\t\t\tcontinue\n\t\t}\n\n\t\tankiAudioFile := fmt.Sprintf(\"anki-support-%s\", audio.Filename)\n\t\tdestinationFile := filepath.Join(c.ankiMediaPath, ankiAudioFile)\n\t\terr = os.WriteFile(destinationFile, input, 0644)\n\t\tif err != nil {\n\t\t\tc.log.Warnln(\"Error creating\", destinationFile)\n\t\t\tc.log.Warnln(err.Error())\n\t\t\toldAudioList = append(oldAudioList, audio)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, field := range audio.Fields {\n\t\t\tupdateFields[field] = fmt.Sprintf(\"[sound:%s]\", ankiAudioFile)\n\t\t}\n\t}\n\terr := c.ankiConnect.Notes.Update(ankiconnect.UpdateNote{\n\t\tId:      note.NoteId,\n\t\tFields:  updateFields,\n\t\tAudio:   oldAudioList,\n\t\tVideo:   videoList,\n\t\tPicture: pictureList,\n\t})\n\treturn NewAnkiError(err)\n}\n\nfunc (c *Client) GetNoteById(id int64) (ankiconnect.ResultNotesInfo, error) {\n\tresult := struct {\n\t\tResult []struct {\n\t\t\tNoteId int64    `json:\"noteId\"`\n\t\t\tTags   []string `json:\"tags\"`\n\t\t\tFields map[string]struct {\n\t\t\t\tValue string `json:\"value\"`\n\t\t\t\tOrder int64  `json:\"order\"`\n\t\t\t} `json:\"fields\"`\n\t\t\tModelName string `json:\"modelName\"`\n\t\t} `json:\"result\"`\n\t\tErr string `json:\"error\"`\n\t}{}\n\terrResult := struct {\n\t\tErr string `json:\"error\"`\n\t}{}\n\tpost, err := c.httpClient.R().SetBodyJsonString(fmt.Sprintf(`\n\t{\n\t\t\"action\": \"notesInfo\",\n\t\t\"version\": 6,\n\t\t\"params\": {\n\t\t\t\"notes\": [%d]\n\t\t}\n\t}\n\t`, id)).\n\t\tSetSuccessResult(&result).\n\t\tSetErrorResult(&errResult).\n\t\tPost(\"\")\n\tif err != nil {\n\t\treturn ankiconnect.ResultNotesInfo{}, err\n\t}\n\tif post.IsErrorState() {\n\t\treturn ankiconnect.ResultNotesInfo{}, fmt.Errorf(\"fail to get note by id\")\n\t}\n\tif result.Err != \"\" {\n\t\treturn ankiconnect.ResultNotesInfo{}, fmt.Errorf(\"fail to get note by id\")\n\t}\n\tfirstNote := result.Result[0]\n\toutput := ankiconnect.ResultNotesInfo{}\n\toutput.NoteId = firstNote.NoteId\n\toutput.ModelName = firstNote.ModelName\n\toutput.Tags = firstNote.Tags\n\toutput.Fields = map[string]ankiconnect.FieldData{}\n\tfor key, value := range firstNote.Fields {\n\t\toutput.Fields[key] = ankiconnect.FieldData{\n\t\t\tValue: value.Value,\n\t\t\tOrder: value.Order,\n\t\t}\n\t}\n\treturn output, nil\n}\n\nfunc (c *Client) DeleteTagFromNote(noteId int64, tag string) error {\n\tresult := struct {\n\t\tError string `json:\"error\"`\n\t}{}\n\tpost, err := c.httpClient.R().SetBodyJsonString(fmt.Sprintf(`\n\t{\n\t\t\"action\": \"removeTags\",\n\t\t\"version\": 6,\n\t\t\"params\": {\n\t\t\t\"notes\": [%d],\n\t\t\t\"tags\": \"%s\"\n\t\t}\n\t}\n\t`, noteId, tag)).\n\t\tSetSuccessResult(&result).\n\t\tPost(\"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"fail to delete note tag\")\n\t}\n\tif post.IsErrorState() {\n\t\treturn fmt.Errorf(\"fail to delete note tag\")\n\t}\n\tif result.Error != \"\" {\n\t\treturn fmt.Errorf(\"fail to delete note tag\")\n\t}\n\treturn nil\n}\n\nfunc (c *Client) AddTagFromNote(id int64, tag string) error {\n\tresult := struct {\n\t\tError string `json:\"error\"`\n\t}{}\n\tpost, err := c.httpClient.R().SetBodyJsonString(fmt.Sprintf(`\n\t{\n\t\t\"action\": \"addTags\",\n\t\t\"version\": 6,\n\t\t\"params\": {\n\t\t\t\"notes\": [%d],\n\t\t\t\"tags\": \"%s\"\n\t\t}\n\t}\n\t`, id, tag)).\n\t\tSetSuccessResult(&result).\n\t\tPost(\"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"fail to add note tag\")\n\t}\n\tif post.IsErrorState() {\n\t\treturn fmt.Errorf(\"fail to add note tag\")\n\t}\n\tif result.Error != \"\" {\n\t\treturn fmt.Errorf(\"fail to add note tag\")\n\t}\n\treturn nil\n}\n\nfunc (c *Client) GetMediaFolderPath() (string, error) {\n\tresult := struct {\n\t\tResult string `json:\"result\"`\n\t\tError  string `json:\"error\"`\n\t}{}\n\tpost, err := c.httpClient.R().SetBodyJsonString(`\n\t{\n\t\t\"action\": \"getMediaDirPath\",\n\t\t\"version\": 6\n\t}\n\t`).SetSuccessResult(&result).Post(\"\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to add note tag\")\n\t}\n\tif post.IsErrorState() {\n\t\treturn \"\", fmt.Errorf(\"fail to add note tag\")\n\t}\n\tif result.Error != \"\" {\n\t\treturn \"\", fmt.Errorf(\"fail to add note tag\")\n\t}\n\treturn result.Result, nil\n}\n\nfunc NewAnkiError(err *errors.RestErr) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t//Message    string `json:\"message\"`\n\t//StatusCode int    `json:\"status\"`\n\t//Error      string `json:\"error\"`\n\treturn fmt.Errorf(\"status: %d, message: %s, error: %s\", err.StatusCode, err.Message, err.Error)\n}\n\ntype Clienter interface {\n\tPing() (err error)\n\tGetAllDeck() ([]string, error)\n\tGetAllNoteFromDeck(name string) ([]ankiconnect.ResultNotesInfo, error)\n\tGetTodoNoteFromDeck(deckName string) ([]ankiconnect.ResultNotesInfo, error)\n\tEditNoteById(\n\t\tnote ankiconnect.ResultNotesInfo,\n\t\taudioList []ankiconnect.Audio,\n\t\tvideoList []ankiconnect.Video,\n\t\tpictureList []ankiconnect.Picture,\n\t) error\n\tGetNoteById(id int64) (ankiconnect.ResultNotesInfo, error)\n\tDeleteTagFromNote(noteId int64, tag string) error\n\tAddTagFromNote(id int64, tag string) error\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/infrastructure/anki/anki.go b/infrastructure/anki/anki.go
--- a/infrastructure/anki/anki.go	(revision 2ab1e4fb639dbc12d4b2495f70bef1cf422e2993)
+++ b/infrastructure/anki/anki.go	(date 1694904546252)
@@ -10,16 +10,16 @@
 	"path/filepath"
 )
 
-type Client struct {
+type Anki struct {
 	ankiConnect   *ankiconnect.Client
 	ankiMediaPath string
 	httpClient    *req.Client
 	log           *logrus.Entry
 }
 
-func NewClient(log *logrus.Logger) *Client {
+func NewClient(log *logrus.Logger) Ankier {
 	field := log.WithField("infrastructure", "anki")
-	c := &Client{log: field}
+	c := &Anki{log: field}
 	c.ankiConnect = ankiconnect.NewClient()
 	c.httpClient = req.C()
 	c.httpClient.SetBaseURL("http://127.0.0.1:8765")
@@ -31,29 +31,29 @@
 	return c
 }
 
-func (c *Client) Ping() (err error) {
+func (c *Anki) Ping() (err error) {
 	restErr := c.ankiConnect.Ping()
 	return NewAnkiError(restErr)
 }
 
-func (c *Client) GetAllDeck() ([]string, error) {
+func (c *Anki) GetAllDeck() ([]string, error) {
 	all, err := c.ankiConnect.Decks.GetAll()
 	return *all, NewAnkiError(err)
 }
 
-func (c *Client) GetAllNoteFromDeck(name string) ([]ankiconnect.ResultNotesInfo, error) {
+func (c *Anki) GetAllNoteFromDeck(name string) ([]ankiconnect.ResultNotesInfo, error) {
 	get, err := c.ankiConnect.Notes.Get(fmt.Sprintf("deck:%s", name))
 	return *get, NewAnkiError(err)
 }
 
-func (c *Client) GetTodoNoteFromDeck(deckName string) ([]ankiconnect.ResultNotesInfo, error) {
+func (c *Anki) GetTodoNoteFromDeck(deckName string) ([]ankiconnect.ResultNotesInfo, error) {
 	todoTag := "anki-helper-vocabulary-todo"
 	get, err := c.ankiConnect.Notes.Get(fmt.Sprintf("tag:%s deck:%s", todoTag, deckName))
 	return *get, NewAnkiError(err)
 }
 
 // EditNoteById should be careful that you can't edit tag, and you can't edit when you open this card on anki gui
-func (c *Client) EditNoteById(
+func (c *Anki) EditNoteById(
 	note ankiconnect.ResultNotesInfo,
 	audioList []ankiconnect.Audio,
 	videoList []ankiconnect.Video,
@@ -99,7 +99,7 @@
 	return NewAnkiError(err)
 }
 
-func (c *Client) GetNoteById(id int64) (ankiconnect.ResultNotesInfo, error) {
+func (c *Anki) GetNoteById(id int64) (ankiconnect.ResultNotesInfo, error) {
 	result := struct {
 		Result []struct {
 			NoteId int64    `json:"noteId"`
@@ -151,7 +151,7 @@
 	return output, nil
 }
 
-func (c *Client) DeleteTagFromNote(noteId int64, tag string) error {
+func (c *Anki) DeleteTagFromNote(noteId int64, tag string) error {
 	result := struct {
 		Error string `json:"error"`
 	}{}
@@ -179,7 +179,7 @@
 	return nil
 }
 
-func (c *Client) AddTagFromNote(id int64, tag string) error {
+func (c *Anki) AddTagFromNote(id int64, tag string) error {
 	result := struct {
 		Error string `json:"error"`
 	}{}
@@ -207,7 +207,7 @@
 	return nil
 }
 
-func (c *Client) GetMediaFolderPath() (string, error) {
+func (c *Anki) GetMediaFolderPath() (string, error) {
 	result := struct {
 		Result string `json:"result"`
 		Error  string `json:"error"`
@@ -240,11 +240,13 @@
 	return fmt.Errorf("status: %d, message: %s, error: %s", err.StatusCode, err.Message, err.Error)
 }
 
-type Clienter interface {
+//go:generate mockgen -destination=anki.mock.go -package=anki -self_package=anki-support/infrastructure/anki . Ankier
+type Ankier interface {
 	Ping() (err error)
 	GetAllDeck() ([]string, error)
 	GetAllNoteFromDeck(name string) ([]ankiconnect.ResultNotesInfo, error)
 	GetTodoNoteFromDeck(deckName string) ([]ankiconnect.ResultNotesInfo, error)
+	GetMediaFolderPath() (string, error)
 	EditNoteById(
 		note ankiconnect.ResultNotesInfo,
 		audioList []ankiconnect.Audio,
